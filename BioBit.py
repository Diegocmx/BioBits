# ==============================================================================
# BioBit + LLM Offline – Diagnóstico Inteligente e Explicável (PT/EN)
# BioBit + Offline LLM – Smart and Explainable Diagnostics (PT/EN)
# Diego Fernando Cruz – 2025
# ==============================================================================

import hashlib
import numpy as np
from pathlib import Path
from gpt4all import GPT4All

# ===================== Funções BioBit Engine DNA ==========================
def ler_dna_fasta(path):
    """
    Lê a sequência de DNA de um arquivo .fasta/.fa/.txt (ignora cabeçalho).
    Reads DNA sequence from .fasta/.fa/.txt file (ignores header lines).
    """
    seq = []
    with open(path, "r") as f:
        for linha in f:
            if not linha.startswith(">"):
                seq.append(linha.strip())
    return ''.join(seq).upper()

def extrair_features_dna(seq):
    """
    Extrai frequência normalizada das bases A, C, G, T.
    Extracts normalized frequency of A, C, G, T bases.
    """
    bases = 'ACGT'
    total = len(seq)
    return [seq.count(b)/total if total > 0 else 0 for b in bases]

def gerar_hash_binaria(vetor, n_bits=64):
    """
    Gera assinatura binária única a partir do vetor de features.
    Generates unique binary signature from feature vector.
    """
    vetor_str = ','.join([f"{x:.6f}" for x in vetor])
    hash_digest = hashlib.sha512(vetor_str.encode()).hexdigest()
    binario = bin(int(hash_digest, 16))[2:].zfill(n_bits * 2)[:n_bits]
    return binario

def gerar_assinatura(seq, tipo):
    """
    Chama extração de features e hash conforme o tipo de dado.
    Calls feature extraction and hash based on data type.
    """
    if tipo == "dna":
        features = extrair_features_dna(seq)
    else:
        raise ValueError("Tipo não suportado // Unsupported type")
    return gerar_hash_binaria(features)

# ==================== Busca Similaridade Binária ==========================
def distancia_hamming(a, b):
    """
    Calcula a distância de Hamming entre duas assinaturas binárias.
    Calculates Hamming distance between two binary signatures.
    """
    return sum(x != y for x, y in zip(a, b))

def carregar_historico(path):
    """
    Carrega o histórico de casos do arquivo CSV.
    Loads the case history from CSV file.
    """
    casos = []
    if not Path(path).exists():
        return casos
    with open(path, "r", encoding="utf-8") as f:
        for linha in f:
            if "," in linha:
                binario, diag = linha.strip().split(",", 1)
                casos.append((binario.strip(), diag.strip()))
    return casos

def buscar_mais_parecidos(binario, historico, n=3):
    """
    Busca os n casos mais próximos no histórico (menor distância de Hamming).
    Finds n most similar cases in history (smallest Hamming distance).
    """
    resultados = []
    for ass, diag in historico:
        dist = distancia_hamming(binario, ass)
        resultados.append((ass, diag, dist))
    resultados.sort(key=lambda x: x[2])
    return resultados[:n]

# =========== Prompt Bilíngue para LLM =============
def montar_prompt(binario, historico):
    """
    Monta o prompt bilíngue para a LLM, incluindo as assinaturas mais próximas.
    Builds a bilingual prompt for the LLM, including most similar signatures.
    """
    prompt = (
        "Você é um assistente médico especialista em diagnósticos explicáveis.\n"
        "Recebe como entrada a ASSINATURA_BINARIA de exames biomédicos, gerada pelo sistema BioBit.\n"
        "Seu objetivo é:\n"
        "- Buscar assinaturas binárias semelhantes no histórico (casos abaixo)\n"
        "- Sugerir possível diagnóstico ou risco com base em casos anteriores\n"
        "- Explicar o motivo, em linguagem médica, em português e inglês\n"
        "- Se for um padrão novo, oriente a investigação ou peça análise manual\n"
        "\n"
        f"ASSINATURA_BINARIA_ATUAL: {binario}\n\n"
        "HISTÓRICO DE CASOS / CASE HISTORY:\n"
    )
    for i, (assin, diag, dist) in enumerate(historico):
        prompt += f"{i+1}. {assin} (distância: {dist}) -> {diag}\n"
    prompt += (
        "\nResponda com um laudo médico objetivo, cite o grau de similaridade se possível.\n"
        "Se não encontrar padrão semelhante, explique que é um caso novo para análise manual.\n"
        "----\n"
        "You are a medical assistant specialized in explainable diagnostics. You receive as input a BINARY_SIGNATURE from biomedical exams, generated by the BioBit system. Your goals:\n"
        "- Search for similar binary signatures in the history below\n"
        "- Suggest possible diagnosis or risk based on previous cases\n"
        "- Explain the reasoning in medical language, both in Portuguese and English\n"
        "- If it is a new pattern, recommend investigation or manual analysis\n"
        f"\nCURRENT_BINARY_SIGNATURE: {binario}\n\n"
        "CASE HISTORY:\n"
    )
    for i, (assin, diag, dist) in enumerate(historico):
        prompt += f"{i+1}. {assin} (distance: {dist}) -> {diag}\n"
    prompt += (
        "\nAnswer with an objective medical report, mention similarity degree if possible.\n"
        "If no similar pattern is found, explain it is a new case for manual analysis."
    )
    return prompt

# ===================== MAIN ======================
if __name__ == "__main__":
    print("="*60)
    print("BioBit + LLM Offline – Diagnóstico Inteligente / Smart Diagnosis")
    print("="*60)

    arquivo = "tp53.fasta"
    tipo = "dna"
    if not Path(arquivo).exists():
        print("Arquivo de exame não encontrado! / Exam file not found!")
        exit()

    seq = ler_dna_fasta(arquivo)
    binario = gerar_assinatura(seq, tipo)
    print("\nAssinatura binária gerada / Binary signature generated:")
    print(binario)

    historico = carregar_historico("historico_casos.csv")
    parecidos = buscar_mais_parecidos(binario, historico, n=3)

    print("\n=== Casos mais semelhantes encontrados no histórico ===")
    print("=== Most similar cases found in history ===")
    for ass, diag, dist in parecidos:
        print(f"Assinatura: {ass}")
        print(f"Diagnóstico: {diag}")
        print(f"Distância de Hamming: {dist}")
        print("---")

    prompt = montar_prompt(binario, parecidos)

    print("\nAguarde, gerando laudo pela IA... / Please wait, generating AI report...\n")
    llm = GPT4All("mistral-7b-openorca.Q4_0.gguf")  # troque pelo modelo que você tem / replace with your model name
    with llm.chat_session():
        laudo = llm.generate(prompt, max_tokens=350)
    print("=== Laudo gerado pela IA ===")
    print("=== AI-generated report ===\n")
    print(laudo)
